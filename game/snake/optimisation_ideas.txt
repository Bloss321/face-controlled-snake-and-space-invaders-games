To optimise the simple snake game:


* should the calibration process and face tracking game control use the same windows?
* mediapipe window & pygame window should open & close simultaneously
* can I place the mediapipe window & pygame window in the same window



* when the player hits the boundary their game ends, but I shouldn't reload the entire window, just:
- reset player score to 0
- update the result metrics with game failed as well as their score
- display game failed window briefly
- don't reset timer



TO SAVE TIME

SNAKE:
- for now: yaw & pitch for movements
- optimise as much as possible
- increase the speed of the snake by 0.1 each time a second passes
- use the same opencv window throughout process
- when failed, don't restart game:
  - set score to 0
  - set all the class attributes to orignal values
  - count the failures in a list that isn't cleared
  - have a quick message appear on the screen (game failed)
  - keep timer going
  - update result metrics
- prettify mediapipe facial landamrks output
- mediapipe and pygame should run sychronously & quit simultaneously
- can I do something about the frame rate?
- calibration process first, then give user time to start themselves
  - have a start game button, for when user is ready
- place mediapipe and pygame windows in same window
  - have the window appear at forefront of screen
  - window should always be in front of other windows on the screen


LEGACY Head-pose estimation code:
`
                    if frame_count < 50:
                        print("is the frame count under 50 working?")
                        neutral_roll_angles.append(roll_degrees)
                        neutral_pitch_angles.append(pitch_degrees)
                    else:
                        print("is this working?")
                        # the roll and pitch angles when the user's head is in a neutral position
                        avg_neutral_roll_angle = np.mean(neutral_roll_angles)
                        avg_neutral_pitch_angle = np.mean(neutral_pitch_angles)
                        roll_angle_diff = abs(abs(avg_neutral_roll_angle) - abs(roll_degrees))
                        pitch_angle_diff = abs(pitch_degrees - avg_neutral_pitch_angle)
                        # I can check the position of the nose compared to the neutral position for the roll action,
                        # the position of the nose is likely to be the same? for the pitch action, there's likely to
                        # be a fairly extreme different in position of the centre of the nose
                        if roll_angle_diff > pitch_angle_diff:  # <-- this doesn't work
                            if roll_degrees > avg_neutral_roll_angle and abs(avg_neutral_roll_angle) - abs(
                                    roll_degrees) >= 4:
                                direction = "right"  # double check if it is the opposite
                                snake.direction = Direction.RIGHT
                            if roll_degrees < avg_neutral_roll_angle and abs(roll_degrees) - abs(
                                    avg_neutral_roll_angle) >= 4:
                                direction = "left"
                                snake.direction = Direction.LEFT
                        elif pitch_angle_diff > roll_angle_diff:
                            if pitch_degrees > avg_neutral_pitch_angle and pitch_degrees - avg_neutral_pitch_angle >= 3:
                                direction = "up"
                                snake.direction = Direction.UP
                            if pitch_degrees < avg_neutral_pitch_angle and avg_neutral_pitch_angle - pitch_degrees >= 5:
                                direction = "down"
                                snake.direction = Direction.DOWN

            frame_count += 1
            frame_60 = resize_video_output(frame, 0.5)
            cv2.imshow(window_name, frame_60)
            cv2.moveWindow(window_name, 10, 50)


            frame_60 = resize_video_output(frame, 0.5)
            # cv2.imshow(window_name, frame_60)
            # cv2.moveWindow(window_name, 10, 50)
            # cv2.setWindowProperty(window_name, cv2.WND_PROP_TOPMOST, 1)
            # win32gui.SetForegroundWindow(win32gui.FindWindow(None, window_name))

`

* More legacy text:

`
 def advanced_hand_controlled_game():
        import game.snake.advanced.advanced_snake_game_hand_controlled as advanced_hand
        advanced_hand.run_game(time.time(), advanced_game_result_metrics, file_name)


    def advanced_face_detection_game():
        import cv2
        from game.snake.common.face_detector_logic import Calibrate
        import game.snake.advanced.advanced_snake_face_detection as advanced_face

        c = Calibrate()
        calibration_results = c.general_calibration(cv2.VideoCapture(0))
        advanced_face.run_game_with_detector_adv(time.time(), advanced_game_result_metrics, calibration_results,
                                                 file_name)

        def mp_advanced_face_detection_game():
        import cv2
        import mediapipe as mp
        from game.snake.common.face_detector_logic_mediapipe import Calibrate
        import game.snake.advanced.advanced_snake_face_detection_mediapipe as mp_advanced_face

        mp_face_mesh = mp.solutions.face_mesh
        face_mesh = mp_face_mesh.FaceMesh()

        mp_file_name = "mp_test.txt"

        c = Calibrate()
        calibration_results = c.general_calibration(cv2.VideoCapture(0), face_mesh, mp_face_mesh)
        mp_advanced_face.run_game_with_detector_adv(time.time(), advanced_game_result_metrics, calibration_results,
                                                    mp_file_name)
`